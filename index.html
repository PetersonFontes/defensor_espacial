<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defensor Espacial: A Invasão</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #000411;
            color: #E0E0E0;
            overflow: hidden;
        }
        canvas {
            background: #000411 url('data:image/svg+xml,%3Csvg width="100" height="100" viewBox="0_0_100_100" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M-1,1 l2,-2 M0,100 l100,-100 M99,101 l2,-2" stroke="%231a202c" stroke-width="0.5"%3E%3C/path%3E%3C/svg%3E');
            cursor: crosshair;
        }
        .hud-text {
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
        }
        .gemini-button {
            transition: all 0.2s ease-in-out;
        }
        .gemini-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px currentColor, 0 0 25px currentColor;
        }
        .gemini-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        kbd {
            background-color: #374151;
            border-radius: 4px;
            padding: 2px 6px;
            border: 1px solid #6b7280;
            font-family: monospace;
        }
        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Warning Animation */
        @keyframes flashWarning {
            0%, 100% { color: #ffcc00; text-shadow: 0 0 10px #ffcc00; }
            50% { color: #ff3300; text-shadow: 0 0 20px #ff3300; }
        }
        .warning-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            animation: flashWarning 1s infinite;
            display: none; /* Hidden by default */
            z-index: 5;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen m-0">

    <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-85 z-20 text-center p-4">
        <h1 class="text-6xl font-bold text-cyan-400 mb-4 hud-text">DEFENSOR ESPACIAL</h1>

        <div class="flex items-center justify-center mb-6">
            <input type="text" id="shipNameInput" placeholder="Nome da sua nave..." class="bg-gray-800 text-white text-center rounded-l-lg p-2 border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-400 w-64">
            <button id="generateNameButton" title="Gerar nome com IA" class="bg-cyan-500 text-white font-bold p-2.5 rounded-r-lg hover:bg-cyan-600 disabled:bg-gray-500 gemini-button">✨</button>
        </div>

        <div class="mb-10">
            <p class="text-xl mb-2">Use as <kbd>SETAS</kbd> para mover e <kbd>ESPAÇO</kbd> para atirar.</p>
            <p class="text-xl">Aguarde o carregamento e use <kbd>Z</kbd> para o RAIO LASER!</p>
        </div>
        
        <button id="startButton" class="gemini-button bg-green-500 text-white font-bold py-3 px-8 rounded-lg text-2xl shadow-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75" style="color: #4ade80;" disabled>Iniciar Jogo</button>
    </div>

    <canvas id="gameCanvas" width="800" height="600" class="hidden"></canvas>
    <div id="warningText" class="warning-text">! CHEFE IMINENTE !</div>

    <div id="gameOverScreen" class="hidden absolute inset-0 flex-col items-center justify-center bg-black bg-opacity-85 z-10 text-center p-4 overflow-y-auto">
        <h2 class="text-5xl font-bold text-red-500 mb-2" style="text-shadow: 0 0 10px #ff0000;">GAME OVER</h2>
        <p class="text-3xl mb-4">Sua pontuação: <span id="finalScore" class="text-yellow-400">0</span></p>
        
        <div class="flex space-x-2 mb-4">
            <button id="analyzePerformanceButton" class="gemini-button bg-yellow-500 text-black font-bold py-2 px-4 rounded-lg text-md shadow-lg hover:bg-yellow-600" style="color: #f59e0b;">✨ Analisar Desempenho</button>
            <button id="generateLogButton" class="gemini-button bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg text-md shadow-lg hover:bg-indigo-600" style="color: #a5b4fc;">✨ Gerar Diário de Bordo</button>
        </div>

        <div id="analysisContainer" class="w-full max-w-2xl min-h-[100px] bg-gray-900 bg-opacity-50 p-4 rounded-lg border border-gray-600 mb-4 text-left text-gray-400 italic">
            Aguardando análise...
        </div>
        
        <button id="restartButton" class="gemini-button bg-green-500 text-white font-bold py-3 px-8 rounded-lg text-2xl shadow-lg hover:bg-green-600" style="color: #4ade80;">Reiniciar (R)</button>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen'); const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore'); const startButton = document.getElementById('startButton'); const restartButton = document.getElementById('restartButton');
        const warningText = document.getElementById('warningText');
        // --- Gemini Elements ---
        const shipNameInput = document.getElementById('shipNameInput'); const generateNameButton = document.getElementById('generateNameButton'); const analyzePerformanceButton = document.getElementById('analyzePerformanceButton'); const generateLogButton = document.getElementById('generateLogButton'); const analysisContainer = document.getElementById('analysisContainer');

        // --- Game State & Objects ---
        let score, lives, difficultyLevel, gameOver, gameRunning, lastMeteorSpawn, lastEnemySpawn; let lastShot = 0; const shotCooldown = 250; 
        const ship = { x: canvas.width / 2 - 25, y: canvas.height - 80, width: 50, height: 50, speed: 7, color: '#00ffff', shieldHealth: 0, shieldRadius: 45 };
        const bullets = [], meteors = [], particles = [], powerups = [], enemies = [], enemyBullets = [], stars = [];
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, ' ': false, z: false };
        let gameStartTime = 0, elapsedTimeStr = '00:00', currentShipName = '';
        // --- Boss State ---
        let boss = null; let isBossActive = false; let nextBossScore = 1000; let firstBossDefeated = false; let bossesDefeated = 0;
        // --- Laser State ---
        let isLaserActive = false; let laserCharge = 100; let lastLaserTime = 0; const laserCooldown = 10000; const laserDuration = 1500; let laserActiveUntil = 0;
        // --- Comms Chatter State ---
        let commsChatter = { text: '', alpha: 0, life: 0, maxLife: 240, color: '#00ffff' }; let lastChatterRequest = 0; const chatterInterval = 15000; // Reduced interval
        // --- Audio State ---
        let isMuted = false;
        const muteButton = { x: canvas.width - 50, y: 55, width: 30, height: 30 };
        let kick, hihat, bassSynth, melodySeq;


        function initializeGame() {
            score = 0; lives = 5; difficultyLevel = 1; gameOver = false; gameRunning = true;
            ship.x = canvas.width / 2 - 25; ship.y = canvas.height - 80; ship.shieldHealth = 0;
            [bullets, meteors, particles, powerups, enemies, enemyBullets].forEach(arr => arr.length = 0);
            lastMeteorSpawn = 0; lastEnemySpawn = 0; boss = null; isBossActive = false; nextBossScore = 1000; firstBossDefeated = false; bossesDefeated = 0;
            laserCharge = 100; lastLaserTime = -laserCooldown; isLaserActive = false; // Start fully charged
            commsChatter = { text: '', alpha: 0, life: 0, maxLife: 240, color: '#00ffff' };
            lastChatterRequest = Date.now();
            gameStartTime = Date.now();
            currentShipName = shipNameInput.value || 'Defensor Anónimo';
            gameOverScreen.classList.add('hidden'); gameOverScreen.classList.remove('flex');
            analysisContainer.innerHTML = 'Aguardando análise...'; analysisContainer.classList.add('italic', 'text-gray-400');
            gameLoop();
        }

        // --- Gemini API ---
        async function callGemini(prompt, targetElement, buttonToDisable) { 
            let originalButtonContent = '';
            if(buttonToDisable) { 
                originalButtonContent = buttonToDisable.innerHTML; 
                buttonToDisable.innerHTML = '<div class="spinner"></div>'; 
                buttonToDisable.disabled = true; 
            } 
            if(targetElement) { 
                targetElement.innerHTML = '<span class="animate-pulse">A gerar...</span>'; 
                targetElement.classList.remove('italic', 'text-gray-400'); 
            } 
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`; 
            try { 
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) }); 
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`); 
                const result = await response.json(); 
                const text = result.candidates?.[0]?.content?.parts?.[0]?.text; 
                if (text) { 
                    if(targetElement) targetElement.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); 
                    return text; 
                } else { 
                    throw new Error("Resposta da API inválida."); 
                } 
            } catch (error) { 
                console.error("Erro ao chamar a API Gemini:", error); 
                const errorMessage = "Ocorreu um erro de comunicação. Tente novamente."; 
                if(targetElement) targetElement.innerHTML = errorMessage; 
                return errorMessage; 
            } finally { 
                if(buttonToDisable) { 
                    buttonToDisable.innerHTML = originalButtonContent; 
                    buttonToDisable.disabled = false; 
                } 
            } 
        }
        async function generateShipName() { generateNameButton.disabled = true; generateNameButton.innerHTML = '<div class="spinner w-4 h-4"></div>'; shipNameInput.value = "A gerar..."; const prompt = "Gere um nome criativo, sonoro e épico para uma nave espacial solitária. O nome deve ser curto, no máximo 2 ou 3 palavras. Responda apenas com o nome e mais nada. Exemplos: Vingança Estelar, Lâmina de Orion, Sussurro do Vazio."; const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`; try { const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) }); const result = await response.json(); shipNameInput.value = result.candidates?.[0]?.content?.parts?.[0]?.text.trim() || "Defensor Padrão"; shipNameInput.dispatchEvent(new Event('input')); } catch (error) { console.error("Erro ao gerar nome da nave:", error); shipNameInput.value = "Defensor Padrão"; } finally { generateNameButton.disabled = false; generateNameButton.textContent = '✨'; } }
        async function generateChatter() { 
            let prompt = '';
            if (isBossActive) {
                prompt = `Você é a IA de uma nave-mãe inimiga arrogante, lutando contra uma pequena nave humana chamada '${currentShipName}'. Gere uma única frase de rádio curta, intimidatória ou provocadora para o piloto. Seja conciso. Não use aspas. Exemplos: "Seus esforços são fúteis, pequena nave.", "Essa sua arma de brincar mal arranha a minha pintura.", "Os meus escudos são eternos. A sua esperança não."`;
                commsChatter.color = '#FF00FF'; // Magenta
            } else {
                let context = "geral";
                if (score > 1500) context = "de vitória";
                else if (lives <= 2) context = "de perigo";
                prompt = `Gere uma única frase curta de comunicação de rádio para um jogo de batalha espacial. O tom deve ser ${context}. A mensagem deve ser concisa e imersiva. Não use aspas. Exemplos: "Os escudos estão a falhar!", "Aguenta, reforços a caminho!", "Excelente tiro, piloto!", "Transmissão não identificada na frequência 3.7."`;
                commsChatter.color = '#00ffff'; // Cyan
            }

            const chatter = await callGemini(prompt, null, null); 
            if (chatter && !chatter.startsWith("Ocorreu um erro")) { 
                commsChatter.text = `> ${chatter.trim()}`; 
                commsChatter.life = commsChatter.maxLife; 
                commsChatter.alpha = 0; 
            } 
        }
        
        // --- Audio Setup ---
        function setupAudio() {
            if (bassSynth) return; // Prevenir reinicialização

            // Bass Synth for the main arpeggio
            bassSynth = new Tone.MonoSynth({
                oscillator: { type: 'sawtooth' },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.5 },
                filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5, baseFrequency: 200, octaves: 4 }
            }).toDestination();
            
            // Drums
            kick = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 10,
                oscillator: { type: 'sine' },
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' }
            }).toDestination();
            
            hihat = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0 }
            }).toDestination();

            // Arpeggio Sequence
            const sequence = [
                'C2', 'G2', 'Bb2', 'G2', 'C2', 'G2', 'Eb3', 'G2',
                'F2', 'C3', 'D#3', 'C3', 'F2', 'C3', 'D#3', 'C3'
            ];
            melodySeq = new Tone.Sequence((time, note) => {
                bassSynth.triggerAttackRelease(note, '16n', time);
            }, sequence, '8n').start(0);

            // Drum Loop
            const drumLoop = new Tone.Loop(time => {
                kick.triggerAttackRelease('C1', '8n', time);
                hihat.triggerAttackRelease('16n', time + Tone.Time('8n').toSeconds());
                hihat.triggerAttackRelease('16n', time + Tone.Time('4n').toSeconds());
                hihat.triggerAttackRelease('16n', time + Tone.Time('4n').toSeconds() + Tone.Time('8n').toSeconds());
            }, '4n').start(0);
            
            Tone.Transport.bpm.value = 130;
            if (Tone.Transport.state !== 'started') {
                Tone.Transport.start();
            }
        }

        function toggleMute() {
            isMuted = !isMuted;
            if (typeof Tone !== 'undefined') {
                 Tone.Destination.mute = isMuted;
            }
        }

        // --- Event Listeners ---
        startButton.addEventListener('click', async () => { 
            // Tenta iniciar o áudio primeiro, mas não impede o jogo de começar
            if (typeof Tone !== 'undefined') {
                try {
                    await Tone.start();
                    console.log("Audio context started");
                    setupAudio();
                } catch (e) {
                    console.error("Não foi possível iniciar o contexto de áudio, o jogo continuará sem som:", e);
                }
            } else {
                console.warn("A biblioteca de áudio (Tone.js) não foi carregada a tempo. O jogo iniciará sem som.");
            }
            
            // Inicia o jogo
            startScreen.style.display = 'none'; 
            canvas.classList.remove('hidden'); 
            initializeGame();
        });
        restartButton.addEventListener('click', () => { 
            startScreen.style.display = 'flex'; 
            canvas.classList.add('hidden'); 
            gameOverScreen.classList.add('hidden'); 
            gameOverScreen.classList.remove('flex');
            if (typeof Tone !== 'undefined' && Tone.Transport.state === 'started') Tone.Transport.stop();
        });
        generateNameButton.addEventListener('click', generateShipName);
        shipNameInput.addEventListener('input', () => {
            startButton.disabled = shipNameInput.value.trim() === '';
        });
        analyzePerformanceButton.addEventListener('click', async () => { const shipName = shipNameInput.value || "Defensor Padrão"; const prompt = `Você é um oficial de debriefing de missão espirituoso e ligeiramente sarcástico. Um piloto acabou de terminar uma missão contra um enxame de meteoros e naves inimigas na sua nave, a **${shipName}**. A sua pontuação final foi de **${score}** e alcançou o nível de dificuldade **${Math.floor(difficultyLevel)}**. Escreva uma análise curta e engraçada, de um parágrafo, do seu desempenho. Se a pontuação for baixa (abaixo de 500), seja mais sarcástico. Se a pontuação for alta (acima de 2000), mostre-se mais impressionado, mas ainda com um toque de humor.`; await callGemini(prompt, analysisContainer, analyzePerformanceButton); });
        generateLogButton.addEventListener('click', async () => { const shipName = shipNameInput.value || "Defensor Padrão"; const prompt = `Você é o capitão da nave espacial **${shipName}**. Escreva uma entrada final e dramática no diário de bordo, com 2-3 parágrafos, após uma batalha feroz contra meteoros e caças inimigos. A sua pontuação foi **${score}**. Reflita sobre a intensidade da batalha, as perdas (se a pontuação for baixa) ou a vitória esmagadora (se a pontuação for alta). Termine com um tom sombrio ou esperançoso, dependendo do resultado.`; await callGemini(prompt, analysisContainer, generateLogButton); });
        window.addEventListener('keydown', (e) => { if (keys.hasOwnProperty(e.key)) { e.preventDefault(); keys[e.key] = true; } if (e.key.toLowerCase() === 'r' && gameOver) restartButton.click(); });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            if (x >= muteButton.x && x <= muteButton.x + muteButton.width && y >= muteButton.y && y <= muteButton.y + muteButton.height) {
                toggleMute();
            }
        });
        
        // --- Object Creation & Helpers ---
        function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }
        for (let i = 0; i < 150; i++) { stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 0.5, speed: Math.random() * 1.5 + 0.5 }); }
        function createExplosion(x, y, color, count = 20) { for (let i = 0; i < count; i++) { particles.push({ x, y, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, size: Math.random() * 3 + 1, life: Math.random() * 40 + 20, color: color }); } }
        function spawnMeteor() { let size, health; const sizeType = Math.random(); if (sizeType < 0.5) { size = 30; health = 1; } else if (sizeType < 0.85) { size = 45; health = 2; } else { size = 65; health = 4; } const meteor = { x: Math.random() * (canvas.width - size), y: -size, size, speed: (Math.random() * 1.5 + 1) * difficultyLevel, health, points: 30, angle: 0, rotationSpeed: (Math.random() - 0.5) * 0.02, vertices: [], craters: [] }; const numVertices = 12; for (let i = 0; i < numVertices; i++) { const angle = (i / numVertices) * Math.PI * 2; const radius = meteor.size / 2 * (Math.random() * 0.3 + 0.85); meteor.vertices.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius }); } for (let i=0; i < 5; i++) { const angle = Math.random() * Math.PI * 2; const radius = Math.random() * (meteor.size / 3); meteor.craters.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius, radius: Math.random() * 4 + 2 }); } meteors.push(meteor); }
        function spawnEnemy(typeOverride = null) {
            let enemyType = typeOverride;
            if (!typeOverride) {
                const rand = Math.random();
                if (bossesDefeated >= 2 && rand < 0.25) {
                    enemyType = 'green';
                } else if (firstBossDefeated && rand < 0.60) {
                    enemyType = 'yellow';
                } else {
                    enemyType = 'red';
                }
            }

            if (enemyType === 'red') {
                enemies.push({ type: 'red', x: Math.random() * (canvas.width - 40), y: -40, width: 40, height: 30, speedX: (Math.random() - 0.5) * 4, speedY: 1 * difficultyLevel, health: 3, lastShot: Date.now(), shotCooldown: 2000 / difficultyLevel, points: 60 });
            } else if (enemyType === 'green') {
                enemies.push({ type: 'green', x: Math.random() * (canvas.width - 40), y: -40, width: 40, height: 40, speedX: 2.5 * difficultyLevel, speedY: 1 * difficultyLevel, health: 5, lastShot: Date.now(), shotCooldown: 2200 / difficultyLevel, points: 90, phase: 'descending', targetY: Math.random() * 100 + 50 });
            } else { // Yellow enemy
                enemies.push({ type: 'yellow', x: Math.random() * (canvas.width - 40), y: -40, width: 35, height: 40, speedX: 0, speedY: 1.5 * difficultyLevel, health: 4, lastShot: Date.now(), shotCooldown: 1500 / difficultyLevel, points: 75, phase: 'down', moveRange: { top: Math.random() * 100 + 80, bottom: Math.random() * 100 + 250 } });
            }
        }
        function spawnBoss() {
            isBossActive = true;
            [enemies, meteors, enemyBullets].forEach(arr => arr.length = 0); // Clear the field
            warningText.style.display = 'block';
            setTimeout(() => {
                warningText.style.display = 'none';
                boss = {
                    x: canvas.width / 2 - 100, y: -200, width: 200, height: 120,
                    speedX: 2 * difficultyLevel, health: 150 * difficultyLevel, maxHealth: 150 * difficultyLevel,
                    phase: 'entering', phaseTime: Date.now(),
                    lastShot: Date.now(), shotCooldown: 1000, shotPattern: 0,
                    lastMinionSpawn: Date.now()
                };
            }, 3000); // 3-second warning
        }

        // --- Drawing Functions ---
        function drawShip() {
            const { x, y, width, height } = ship;
            // Thruster
            if (Object.values(keys).some(k => k)) { ctx.fillStyle = `rgba(255, 180, 50, ${Math.random() * 0.5 + 0.5})`; ctx.beginPath(); ctx.moveTo(x + width/2 - 6, y + height); ctx.lineTo(x + width/2 + 6, y + height); ctx.lineTo(x + width/2, y + height + Math.random() * 20 + 15); ctx.closePath(); ctx.fill(); }
            // Body
            ctx.fillStyle = '#B0C4DE'; ctx.beginPath(); ctx.moveTo(x + width/2, y); ctx.lineTo(x, y + height * 0.85); ctx.lineTo(x + width/2, y + height); ctx.lineTo(x + width, y + height * 0.85); ctx.closePath(); ctx.fill();
            // Cockpit
            ctx.fillStyle = ship.color; ctx.beginPath(); ctx.moveTo(x + width/2, y + 5); ctx.lineTo(x + width/2 - 5, y + 20); ctx.lineTo(x + width/2 + 5, y + 20); ctx.closePath(); ctx.fill();
            // Shield
            if (ship.shieldHealth > 0) { ctx.lineWidth = 2.5; for (let i = 0; i < ship.shieldHealth; i++) { const radius = ship.shieldRadius - (i * 7); const alpha = 0.4 + (i * 0.2); ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`; ctx.beginPath(); ctx.arc(x + width / 2, y + height / 2, radius, 0, Math.PI * 2); ctx.stroke(); } }
        }
        function drawBoss() {
            if (!boss) return;
            // Main Body
            ctx.fillStyle = '#4B0082'; // Indigo
            ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
            // Cockpit
            ctx.fillStyle = '#FF00FF'; // Magenta
            ctx.fillRect(boss.x + boss.width/2 - 20, boss.y + 20, 40, 30);
            // Wings
            ctx.fillStyle = '#8A2BE2'; // BlueViolet
            ctx.beginPath();
            ctx.moveTo(boss.x, boss.y + 20); ctx.lineTo(boss.x - 40, boss.y + 80); ctx.lineTo(boss.x, boss.y + 80);
            ctx.closePath(); ctx.fill();
            ctx.beginPath();
            ctx.moveTo(boss.x + boss.width, boss.y + 20); ctx.lineTo(boss.x + boss.width + 40, boss.y + 80); ctx.lineTo(boss.x + boss.width, boss.y + 80);
            ctx.closePath(); ctx.fill();
            // Health Bar
            ctx.fillStyle = '#8B0000';
            ctx.fillRect(boss.x, boss.y - 20, boss.width, 10);
            const healthPercent = boss.health / boss.maxHealth;
            ctx.fillStyle = '#00FF00';
            ctx.fillRect(boss.x, boss.y - 20, boss.width * healthPercent, 10);
        }
        function drawLaser() { if (!isLaserActive) return; const laserWidth = 20; const grad = ctx.createLinearGradient(ship.x, 0, ship.x + laserWidth, 0); grad.addColorStop(0, 'rgba(255, 0, 0, 0.1)'); grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)'); grad.addColorStop(1, 'rgba(255, 0, 0, 0.1)'); ctx.fillStyle = grad; ctx.shadowColor = 'red'; ctx.shadowBlur = 30; ctx.fillRect(ship.x + ship.width / 2 - laserWidth / 2, -10, laserWidth, ship.y + 10); ctx.shadowBlur = 0; }
        function drawEnemies() { enemies.forEach(enemy => { 
            if (enemy.type === 'red') { 
                ctx.fillStyle = '#ff4d4d'; 
                ctx.beginPath(); 
                ctx.moveTo(enemy.x, enemy.y); 
                ctx.lineTo(enemy.x + enemy.width, enemy.y); 
                ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height); 
                ctx.closePath(); ctx.fill(); 
            } else if (enemy.type === 'green') {
                ctx.fillStyle = '#22c55e'; // Green
                ctx.beginPath();
                ctx.moveTo(enemy.x + enemy.width/2, enemy.y); // Top point
                ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/2); // Right point
                ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height); // Bottom point
                ctx.lineTo(enemy.x, enemy.y + enemy.height/2); // Left point
                ctx.closePath();
                ctx.fill();
            } else { // Yellow
                ctx.fillStyle = '#ffd700'; 
                ctx.beginPath(); 
                ctx.moveTo(enemy.x + enemy.width/2, enemy.y); 
                ctx.lineTo(enemy.x, enemy.y + enemy.height); 
                ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height); 
                ctx.closePath(); ctx.fill(); 
            } 
        }); }
        function drawEnemyBullets() { enemyBullets.forEach(b => { ctx.fillStyle = '#ff8c00'; ctx.shadowColor = '#ff8c00'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; }); }
        function drawStars() { ctx.fillStyle = '#FFFFFF'; stars.forEach(star => { ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill(); }); }
        function drawBullets() { bullets.forEach(bullet => { ctx.shadowBlur = 15; ctx.fillStyle = '#FFF'; ctx.shadowColor = '#00ffff'; ctx.beginPath(); ctx.arc(bullet.x, bullet.y, 6, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; }); }
        function drawMeteors() { meteors.forEach(meteor => { meteor.angle += meteor.rotationSpeed; ctx.save(); ctx.translate(meteor.x, meteor.y); ctx.rotate(meteor.angle); const grad = ctx.createRadialGradient(0, 0, meteor.size / 4, 0, 0, meteor.size / 1.5); grad.addColorStop(0, '#C0C0C0'); grad.addColorStop(1, '#696969'); ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(meteor.vertices[0].x, meteor.vertices[0].y); for (let i = 1; i < meteor.vertices.length; i++) { ctx.lineTo(meteor.vertices[i].x, meteor.vertices[i].y); } ctx.closePath(); ctx.fill(); ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; meteor.craters.forEach(crater => { ctx.beginPath(); ctx.arc(crater.x, crater.y, crater.radius, 0, Math.PI * 2); ctx.fill(); }); ctx.strokeStyle = '#404040'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); }); }
        function drawParticles() { particles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); }
        function drawPowerups() { powerups.forEach(p => { ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 15; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 14px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('S', p.x, p.y); ctx.shadowBlur = 0; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }); }
        function drawHUD() {
            ctx.fillStyle = '#FFFFFF'; 
            ctx.font = '20px Orbitron'; 
            
            // --- Top Info Bar ---
            ctx.textAlign = 'left';
            ctx.fillText(`NAVE: ${currentShipName}`, 20, 40);
            ctx.textAlign = 'right';
            ctx.fillText(`PONTOS: ${score}`, canvas.width - 20, 40);

            // --- Second Info Bar ---
            const secondRowY = 70;
            ctx.font = '14px Orbitron';

            // --- Vidas ---
            ctx.textAlign = 'left';
            ctx.fillText(`VIDAS:`, 20, secondRowY);
            for (let i = 0; i < lives; i++) { 
                ctx.save(); ctx.translate(80 + (i * 20), secondRowY - 10); ctx.scale(0.3, 0.3);
                ctx.fillStyle = '#B0C4DE'; ctx.beginPath(); ctx.moveTo(ship.width/2, 0); ctx.lineTo(0, ship.height * 0.85); ctx.lineTo(ship.width/2, ship.height); ctx.lineTo(ship.width, ship.height * 0.85); ctx.closePath(); ctx.fill(); 
                ctx.restore(); 
            }

            // --- Temporizador ---
            ctx.textAlign = 'left';
            ctx.fillText(`TEMPO: ${elapsedTimeStr}`, 210, secondRowY);

            // --- Barra do Laser ---
            const laserSectionX = 400;
            ctx.textAlign = 'left';
            ctx.fillText('LASER:', laserSectionX, secondRowY);
            const laserBarX = laserSectionX + 65; const laserBarY = secondRowY - 10; const laserBarWidth = 110; const laserBarHeight = 12;
            ctx.strokeStyle = laserCharge >= 100 ? '#ff4500' : '#8B0000'; ctx.lineWidth = 1; ctx.strokeRect(laserBarX, laserBarY, laserBarWidth, laserBarHeight);
            const chargePercent = laserCharge / 100; const laserGradient = ctx.createLinearGradient(laserBarX, 0, laserBarX + laserBarWidth, 0); laserGradient.addColorStop(0, '#8B0000'); laserGradient.addColorStop(1, '#ff4500'); 
            ctx.fillStyle = laserGradient; ctx.fillRect(laserBarX, laserBarY, laserBarWidth * chargePercent, laserBarHeight);
            if (laserCharge >= 100) { ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 10px Orbitron'; ctx.textAlign = 'center'; ctx.fillText("PRONTO", laserBarX + laserBarWidth/2, secondRowY - 1); }
            ctx.font = '14px Orbitron';
            
            // --- Barra de Progresso do Chefe ---
            if (!isBossActive) {
                const bossSectionX = 590;
                const progressPercent = Math.max(0, (score - (nextBossScore - 1000)) / 1000);
                ctx.textAlign = 'left';
                ctx.fillText('CHEFE:', bossSectionX, secondRowY);
                const bossBarWidth = 110; const bossBarHeight = 12; const bossBarX = bossSectionX + 65; const bossBarY = secondRowY - 10;
                ctx.strokeStyle = '#8A2BE2'; ctx.lineWidth = 1; ctx.strokeRect(bossBarX, bossBarY, bossBarWidth, bossBarHeight);
                const bossGradient = ctx.createLinearGradient(bossBarX, 0, bossBarX + bossBarWidth, 0); bossGradient.addColorStop(0, '#4B0082'); bossGradient.addColorStop(1, '#FF00FF');
                ctx.fillStyle = bossGradient; ctx.fillRect(bossBarX, bossBarY, bossBarWidth * progressPercent, bossBarHeight);
            }
            
            // --- Mute Button ---
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(muteButton.x, muteButton.y, muteButton.width, muteButton.height);
            ctx.beginPath();
            ctx.moveTo(muteButton.x + 5, muteButton.y + 10);
            ctx.lineTo(muteButton.x + 10, muteButton.y + 10);
            ctx.lineTo(muteButton.x + 15, muteButton.y + 5);
            ctx.lineTo(muteButton.x + 15, muteButton.y + 25);
            ctx.lineTo(muteButton.x + 10, muteButton.y + 20);
            ctx.lineTo(muteButton.x + 5, muteButton.y + 20);
            ctx.closePath();
            ctx.stroke();
            if (isMuted) {
                ctx.beginPath();
                ctx.moveTo(muteButton.x + 5, muteButton.y + 5);
                ctx.lineTo(muteButton.x + 25, muteButton.y + 25);
                ctx.stroke();
            }

            // --- Comunicações ---
            drawChatter();
        }
        function drawChatter() { 
            if (commsChatter.alpha > 0) { 
                ctx.textAlign = 'center'; 
                ctx.font = 'italic 16px Orbitron';
                const rgb = hexToRgb(commsChatter.color);
                if (rgb) {
                     ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${commsChatter.alpha})`; 
                     ctx.shadowColor = commsChatter.color;
                     ctx.shadowBlur = 10;
                     ctx.fillText(commsChatter.text, canvas.width / 2, canvas.height - 25); 
                     ctx.shadowBlur = 0;
                }
            } 
        }
        
        // --- Update & Logic ---
        function updateState() {
            if (gameOver) return;

            // Atualizar Temporizador
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
            const seconds = String(elapsed % 60).padStart(2, '0');
            elapsedTimeStr = `${minutes}:${seconds}`;

            // Laser update
            if (isLaserActive && Date.now() > laserActiveUntil) isLaserActive = false;
            laserCharge = Math.min(100, ((Date.now() - lastLaserTime) / laserCooldown) * 100);
            // Ship Movement & Firing
            if (keys.ArrowUp && ship.y > 0) ship.y -= ship.speed; if (keys.ArrowDown && ship.y < canvas.height - ship.height) ship.y += ship.speed; if (keys.ArrowLeft && ship.x > 0) ship.x -= ship.speed; if (keys.ArrowRight && ship.x < canvas.width - ship.width) ship.x += ship.speed;
            if (keys[' '] && Date.now() - lastShot > shotCooldown) { bullets.push({ x: ship.x + ship.width / 2, y: ship.y }); lastShot = Date.now(); }
            if (keys.z && laserCharge >= 100) { isLaserActive = true; laserActiveUntil = Date.now() + laserDuration; lastLaserTime = Date.now(); }
            
            // Boss or Regular Spawners
            if (!isBossActive && score >= nextBossScore) { spawnBoss(); }
            if (isBossActive) { updateBoss(); } else {
                if (Date.now() - lastMeteorSpawn > 2000 / difficultyLevel) { spawnMeteor(); lastMeteorSpawn = Date.now(); }
                if (Date.now() - lastEnemySpawn > 5000 / difficultyLevel) { spawnEnemy(); lastEnemySpawn = Date.now(); }
            }
            
            // Updates
            bullets.forEach((b, i) => { b.y -= 10; if (b.y < 0) bullets.splice(i, 1); });
            meteors.forEach((m, i) => { m.y += m.speed; if (m.y > canvas.height + m.size) meteors.splice(i, 1); });
            enemies.forEach((e, i) => {
                if (e.type === 'green') {
                    if (e.phase === 'descending') {
                        e.y += e.speedY;
                        if (e.y >= e.targetY) {
                            e.phase = 'horizontal';
                        }
                    } else { // horizontal phase
                        e.x += e.speedX;
                        if (e.x <= 0 || e.x >= canvas.width - e.width) {
                            e.speedX *= -1;
                        }
                    }
                } else if (e.type === 'yellow') { 
                    if (e.phase === 'down') {
                        e.y += e.speedY;
                        if (e.y >= e.moveRange.bottom) e.phase = 'up';
                    } else { // phase is 'up'
                        e.y -= e.speedY;
                        if (e.y <= e.moveRange.top) e.phase = 'down';
                    }
                } else { // Red enemy logic
                    e.x += e.speedX; e.y += e.speedY;
                    if (e.x <= 0 || e.x >= canvas.width - e.width) e.speedX *= -1;
                }
                if (e.y > canvas.height + e.height) enemies.splice(i, 1); // Remove if off-screen (bottom only)
                if (Date.now() - e.lastShot > e.shotCooldown) {
                    enemyBullets.push({x: e.x + e.width/2, y: e.y + e.height});
                    if (e.type === 'yellow') { // Double shot
                        enemyBullets.push({x: e.x + e.width/2 - 10, y: e.y + e.height});
                        enemyBullets.push({x: e.x + e.width/2 + 10, y: e.y + e.height});
                    }
                    e.lastShot = Date.now();
                }
            });
            enemyBullets.forEach((b, i) => { b.y += 5; if (b.y > canvas.height) enemyBullets.splice(i, 1); });
            powerups.forEach((p, i) => { p.y += 2; if(p.y > canvas.height + p.size) powerups.splice(i, 1); });
            particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); });
            stars.forEach(star => { star.y += star.speed; if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; } });
            
            updateChatter(); 
            checkCollisions();
        }

        function updateBoss() {
            if (!boss) return;
            // Phase Logic
            if (boss.phase === 'entering') {
                boss.y += 3;
                if (boss.y >= 50) { boss.phase = 'attacking'; }
            } else if (boss.phase === 'attacking') {
                boss.x += boss.speedX;
                if (boss.x <= 0 || boss.x + boss.width >= canvas.width) { boss.speedX *= -1; }
                // Shooting patterns
                if (Date.now() - boss.lastShot > boss.shotCooldown) {
                    // Simple spread shot for now
                    for (let i = -2; i <= 2; i++) {
                        enemyBullets.push({ x: boss.x + boss.width/2 + (i * 40), y: boss.y + boss.height });
                    }
                    boss.lastShot = Date.now();
                }

                // Minion Spawning Logic
                const minionSpawnRate = 4500 / difficultyLevel;
                if (Date.now() - boss.lastMinionSpawn > minionSpawnRate) {
                    if (bossesDefeated === 1 || bossesDefeated === 2) {
                        spawnEnemy('red');
                    } else if (bossesDefeated >= 3) {
                        spawnEnemy(Math.random() < 0.5 ? 'red' : 'yellow');
                    }
                    boss.lastMinionSpawn = Date.now();
                }
            }
        }

        function updateChatter() { if (gameRunning && Date.now() - lastChatterRequest > chatterInterval) { generateChatter(); lastChatterRequest = Date.now(); } if (commsChatter.life > 0) { commsChatter.life--; const lifePercentage = commsChatter.life / commsChatter.maxLife; if (lifePercentage > 0.8) { commsChatter.alpha = (1 - lifePercentage) / 0.2; } else if (lifePercentage < 0.2) { commsChatter.alpha = lifePercentage / 0.2; } else { commsChatter.alpha = 1; } } else { commsChatter.alpha = 0; } }
        
        function checkCollisions() {
            const bulletRadius = 6;
            // Laser Collision
            if (isLaserActive) { const laserX = ship.x + ship.width / 2; const laserWidth = 20; meteors.slice().reverse().forEach((meteor, i) => { if (Math.abs(laserX - meteor.x) < meteor.size / 2 + laserWidth / 2) { score += meteor.points; createExplosion(meteor.x, meteor.y, '#ff4500', meteor.size); meteors.splice(meteors.length - 1 - i, 1); } }); enemies.slice().reverse().forEach((enemy, i) => { if (laserX > enemy.x && laserX < enemy.x + enemy.width) { score += enemy.points; createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#ff4500', 40); enemies.splice(enemies.length - 1 - i, 1); } }); if (boss && laserX > boss.x && laserX < boss.x + boss.width) { boss.health -= 2; } } // High damage
            // Player Bullets vs Meteors/Enemies/Boss
            bullets.forEach((bullet, i) => {
                let bulletRemoved = false;
                meteors.forEach((meteor, j) => { if (!bulletRemoved && Math.hypot(bullet.x - meteor.x, bullet.y - meteor.y) < meteor.size / 2 + bulletRadius) { bullets.splice(i, 1); bulletRemoved = true; meteor.health--; createExplosion(bullet.x, bullet.y, '#FFA500', 5); if (meteor.health <= 0) { score += meteor.points; createExplosion(meteor.x, meteor.y, '#696969', meteor.size / 2); if(meteor.size >= 60 && Math.random() < 0.25) { powerups.push({ x: meteor.x, y: meteor.y, size: 20, type: 'shield' }); } meteors.splice(j, 1); } } });
                enemies.forEach((enemy, j) => { if (!bulletRemoved && bullet.x > enemy.x && bullet.x < enemy.x + enemy.width && bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) { bullets.splice(i, 1); bulletRemoved = true; enemy.health--; if(enemy.health <= 0) { score += enemy.points; createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff4d4d', 30); enemies.splice(j, 1); } } });
                if (boss && !bulletRemoved && bullet.x > boss.x && bullet.x < boss.x + boss.width && bullet.y > boss.y && bullet.y < boss.y + boss.height) {
                    bullets.splice(i, 1); bulletRemoved = true; boss.health--; createExplosion(bullet.x, bullet.y, '#FFD700', 5);
                    if (boss.health <= 0) { 
                        // score += boss.points;  // REMOVED BOSS SCORE
                        createExplosion(boss.x + boss.width/2, boss.y + boss.height/2, '#FF00FF', 200); 
                        difficultyLevel += 0.5;
                        bossesDefeated++;
                        if (bossesDefeated >= 2) {
                            nextBossScore += 1500; // Increase interval after the 2nd boss
                        } else {
                            nextBossScore += 1000;
                        }
                        boss = null; 
                        isBossActive = false; 
                        firstBossDefeated = true;
                    }
                }
            });
            // Enemy bullets vs player
            enemyBullets.forEach((b, i) => { if (Math.hypot(b.x - (ship.x+ship.width/2), b.y - (ship.y+ship.height/2)) < ship.width/2) { enemyBullets.splice(i,1); if(ship.shieldHealth > 0){ship.shieldHealth--; createExplosion(ship.x+ship.width/2, ship.y+ship.height/2, '#00ffff', 40);} else {lives--; createExplosion(ship.x+ship.width/2, ship.y+ship.height/2, '#FF4500', 30); if(lives <= 0) endGame();} } });
            // Player vs Meteors/Enemies/Boss
            const checkPlayerCollision = (obj, isMeteor) => { const objWidth = isMeteor ? obj.size : (obj.width || 0); const objX = isMeteor ? obj.x : (obj.x + objWidth / 2); const dist = Math.hypot((ship.x + ship.width/2) - objX, (ship.y + ship.height/2) - (obj.y + objWidth/2)); if (dist < objWidth/2 + ship.width/2) { if (ship.shieldHealth > 0) { ship.shieldHealth--; createExplosion(objX, obj.y + objWidth/2, '#00ffff', 40); } else { lives--; createExplosion(ship.x+ship.width/2, ship.y+ship.height/2, '#FF4500', 30); if(lives <= 0) endGame(); } return true; } return false; };
            meteors.forEach((m, i) => { if(checkPlayerCollision(m, true)) meteors.splice(i, 1); });
            enemies.forEach((e, i) => { if(checkPlayerCollision(e, false)) { enemies.splice(i,1); createExplosion(e.x+e.width/2, e.y+e.height/2, '#ff4d4d', 30); } });
            if (boss && checkPlayerCollision(boss, false)) { /* Player takes damage from boss collision */ }
            // Ship vs Powerups
            powerups.forEach((p, i) => { if(Math.hypot((ship.x + ship.width/2) - p.x, (ship.y + ship.height/2) - p.y) < p.size + ship.width/2) { if(p.type === 'shield') ship.shieldHealth = 3; powerups.splice(i, 1); } });
        }

        function endGame() { 
            gameOver = true; 
            gameRunning = false; 
            finalScoreElement.textContent = score; 
            gameOverScreen.classList.remove('hidden'); 
            gameOverScreen.classList.add('flex');
            if (typeof Tone !== 'undefined' && Tone.Transport.state === 'started') Tone.Transport.stop();
        }
        function gameLoop() { if (!gameRunning) return; updateState(); ctx.clearRect(0, 0, canvas.width, canvas.height); drawStars(); drawPowerups(); drawMeteors(); drawEnemies(); if(isBossActive) drawBoss(); drawShip(); drawLaser(); drawBullets(); drawEnemyBullets(); drawParticles(); drawHUD(); requestAnimationFrame(gameLoop); }
    </script>
</body>
</html>

