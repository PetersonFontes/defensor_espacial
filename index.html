<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Defensor Espacial - Jogue Agora!</title>
    <meta name="description" content="Embarque no Defensor Espacial, um viciante jogo de tiro espacial estilo arcada. Pilote a sua nave através de chuvas de meteoros e enfrente esquadrões de naves inimigas. Jogue grátis agora!">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Estilos Globais */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            font-family: 'Orbitron', sans-serif;
            background-color: #000411;
            color: #E0E0E0;
            touch-action: manipulation;
        }
        .main-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
        }
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            flex-grow: 1;
        }

        /* Estilos do Jogo */
        #game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            height: 80vh;
            margin: 1rem auto;
            overflow: hidden;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            background: #000411 url('data:image/svg+xml,%3Csvg width="100" height="100" viewBox="0_0_100_100" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M-1,1 l2,-2 M0,100 l100,-100 M99,101 l2,-2" stroke="%231a202c" stroke-width="0.5"%3E%3C/path%E%3E%3C/svg%E');
            cursor: crosshair;
        }
        .hud-text { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff; }
        .gemini-button { transition: all 0.2s ease-in-out; }
        .gemini-button:hover { transform: scale(1.05); box-shadow: 0 0 15px currentColor, 0 0 25px currentColor; }
        .gemini-button:disabled { cursor: not-allowed; opacity: 0.5; }
        kbd { background-color: #374151; border-radius: 4px; padding: 2px 6px; border: 1px solid #6b7280; font-family: monospace; }
        .spinner { border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes flashWarning { 0%, 100% { color: #ffcc00; text-shadow: 0 0 10px #ffcc00; } 50% { color: #ff3300; text-shadow: 0 0 20px #ff3300; } }
        .warning-text { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); font-size: clamp(2rem, 10vw, 4rem); font-weight: bold; animation: flashWarning 1s infinite; display: none; z-index: 5; }

        /* Controles Mobile */
        #joystick-area { position: absolute; bottom: 40px; left: 20px; width: 120px; height: 120px; background: rgba(100, 100, 100, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; transform: translate(-50%, -50%); }
        #action-buttons { position: absolute; bottom: 40px; right: 20px; display: flex; flex-direction: column; gap: 15px; align-items: center; }
        #action-buttons button { width: 70px; height: 70px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1rem; font-weight: bold; color: white; user-select: none; }
        #laserButton { background-color: rgba(255, 80, 80, 0.3); border: 2px solid rgba(255, 80, 80, 0.5); }
        #fireButton { background-color: rgba(0, 255, 255, 0.3); border: 2px solid rgba(0, 255, 255, 0.5); }
        #historyScreen table th, #historyScreen table td { padding: 8px 12px; border: 1px solid #4a5568; }

        /* Anúncios */
        .ad-container, .ad-container-vertical, .ad-container-medium-rect {
            margin: 20px auto;
            background-color: #0c1221;
            border: 1px dashed #374151;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
        }
        .ad-container { /* Billboard e banners */
            width: 100%;
            max-width: 970px;
            min-height: 90px;
        }
        .ad-container-vertical { /* Half-page */
            width: 300px;
            height: 600px;
        }
        .ad-container-medium-rect { /* Medium Rectangle */
            width: 300px;
            height: 250px;
        }
        .sidebar-ad {
            width: 300px;
            padding: 20px;
            flex-shrink: 0;
        }
        @media (max-width: 1600px) { .sidebar-ad { display: none; } }
    </style>
</head>
<body class="text-center">

    <div class="main-wrapper">
        <aside class="sidebar-ad">
             <div class="ad-container-vertical"> <span>Anúncio Vertical (300x600)</span> </div>
             <div class="ad-container-medium-rect"> <span>Anúncio Retângulo (300x250)</span> </div>
        </aside>

        <div class="flex-grow">
            <main>
                <div class="ad-container"> <span>Espaço para Anúncio (Billboard)</span> </div>
                <h1 class="text-4xl sm:text-5xl font-bold text-cyan-400 my-8 hud-text">DEFENSOR ESPACIAL</h1>
                <div class="max-w-4xl mx-auto text-lg text-gray-300 px-4">
                    <p class="mb-4"> Prepare-se para uma batalha intergaláctica épica em <strong>Defensor Espacial</strong>! Inspirado nos clássicos jogos de arcada dos anos 80, este shooter espacial coloca-o no comando de uma nave de elite, a última defesa contra hordas de inimigos implacáveis e chuvas de meteoros traiçoeiras. A sua missão é sobreviver o máximo de tempo possível, acumulando pontos ao destruir tudo o que se move. </p>
                    <p> Enfrente diferentes tipos de naves inimigas, cada uma com padrões de ataque únicos, desde os caças vermelhos mais simples aos esquivos interceptores amarelos e às patrulhas verdes. A cada 1000 pontos, prepare-se para o derradeiro desafio: uma gigantesca Nave Mãe que testará os seus reflexos e a sua estratégia. Domine o uso do seu raio laser devastador e colecione power-ups de escudo para aumentar as suas chances de sobrevivência. A sua jornada para se tornar uma lenda do espaço começa agora! </p>
                </div>
                <div id="game-container">
                    <canvas id="gameCanvas" class="hidden"></canvas>
                    <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-85 z-20 text-center p-4">
                         <h2 class="text-3xl font-bold mb-6">Prepare-se para a Batalha</h2>
                        <div class="flex items-center justify-center mb-6">
                            <input type="text" id="shipNameInput" placeholder="Nome da sua nave..." class="bg-gray-800 text-white text-center rounded-l-lg p-2 border border-cyan-400 focus:outline-none focus:ring-2 focus:ring-cyan-400 w-48 sm:w-64">
                            <button id="generateNameButton" title="Gerar nome com IA" class="bg-cyan-500 text-white font-bold p-2.5 rounded-r-lg hover:bg-cyan-600 disabled:bg-gray-500 gemini-button">✨</button>
                        </div>
                        <div class="mb-6 hidden md:block">
                            <p class="text-lg mb-2">Use as <kbd>SETAS</kbd> para mover e <kbd>ESPAÇO</kbd> para atirar.</p>
                            <p class="text-lg">Use <kbd>Z</kbd> para o RAIO LASER!</p>
                        </div>
                        <div class="flex space-x-4">
                             <button id="startButton" class="gemini-button bg-green-500 text-white font-bold py-3 px-8 rounded-lg text-2xl shadow-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-75" style="color: #4ade80;" disabled>Iniciar Jogo</button>
                             <button id="historyButton" class="gemini-button bg-blue-500 text-white font-bold py-3 px-8 rounded-lg text-2xl shadow-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75" style="color: #60a5fa;">Histórico</button>
                        </div>
                    </div>
                    <div id="warningText" class="warning-text">! CHEFE IMINENTE !</div>
                    <div id="mobileControls" class="md:hidden fixed inset-0 z-30 pointer-events-none">
                        <div id="joystick-area" class="pointer-events-auto"><div id="joystick-knob"></div></div>
                        <div id="action-buttons" class="pointer-events-auto"><button id="laserButton">LASER</button><button id="fireButton">TIRO</button></div>
                    </div>
                    <div id="gameOverScreen" class="hidden absolute inset-0 flex-col items-center justify-center bg-black bg-opacity-85 z-10 text-center p-4 overflow-y-auto">
                        <h2 class="text-5xl font-bold text-red-500 mb-2" style="text-shadow: 0 0 10px #ff0000;">GAME OVER</h2>
                        <p class="text-3xl mb-4">Sua pontuação: <span id="finalScore" class="text-yellow-400">0</span></p>
                        <div class="flex space-x-2 mb-4">
                            <button id="analyzePerformanceButton" class="gemini-button bg-yellow-500 text-black font-bold py-2 px-4 rounded-lg text-md shadow-lg hover:bg-yellow-600" style="color: #f59e0b;">✨ Analisar Desempenho</button>
                            <button id="generateLogButton" class="gemini-button bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg text-md shadow-lg hover:bg-indigo-600" style="color: #a5b4fc;">✨ Gerar Diário de Bordo</button>
                        </div>
                        <div id="analysisContainer" class="w-full max-w-2xl min-h-[100px] bg-gray-900 bg-opacity-50 p-4 rounded-lg border border-gray-600 mb-4 text-left text-gray-400 italic">Aguardando análise...</div>
                        <button id="restartButton" class="gemini-button bg-green-500 text-white font-bold py-3 px-8 rounded-lg text-2xl shadow-lg hover:bg-green-600" style="color: #4ade80;">Reiniciar (R)</button>
                    </div>
                    <div id="historyScreen" class="hidden absolute inset-0 flex-col items-center justify-center bg-black bg-opacity-90 z-30 p-4 overflow-y-auto">
                        <h2 class="text-4xl font-bold text-cyan-400 mb-6 hud-text">HISTÓRICO DE PARTIDAS</h2>
                        <div class="w-full max-w-lg max-h-[70vh] overflow-y-auto border-2 border-cyan-500 p-2 rounded-lg">
                            <table class="w-full text-center text-lg">
                                <thead class="sticky top-0 bg-gray-900"><tr><th class="text-yellow-400">Nave</th><th class="text-yellow-400">Pontuação</th></tr></thead>
                                <tbody id="historyTableBody"></tbody>
                            </table>
                        </div>
                        <button id="closeHistoryButton" class="gemini-button mt-6 bg-red-500 text-white font-bold py-2 px-6 rounded-lg text-xl shadow-lg hover:bg-red-600">Fechar</button>
                    </div>
                </div>
            </main>
            <footer class="text-center text-gray-500 py-4">
                <p>&copy; 2024 Defensor Espacial. Todos os direitos reservados.</p>
                <a href="#" class="underline hover:text-cyan-400">Política de Privacidade</a>
            </footer>
        </div>

        <aside class="sidebar-ad">
            <div class="ad-container-vertical"> <span>Anúncio Vertical (300x600)</span> </div>
            <div class="ad-container-medium-rect"> <span>Anúncio Retângulo (300x250)</span> </div>
       </aside>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen'); const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreElement = document.getElementById('finalScore'); const startButton = document.getElementById('startButton'); const restartButton = document.getElementById('restartButton');
        const warningText = document.getElementById('warningText');
        const mobileControls = document.getElementById('mobileControls');
        const historyScreen = document.getElementById('historyScreen');
        const historyButton = document.getElementById('historyButton');
        const closeHistoryButton = document.getElementById('closeHistoryButton');
        const historyTableBody = document.getElementById('historyTableBody');
        const shipNameInput = document.getElementById('shipNameInput'); const generateNameButton = document.getElementById('generateNameButton'); const analyzePerformanceButton = document.getElementById('analyzePerformanceButton'); const generateLogButton = document.getElementById('generateLogButton'); const analysisContainer = document.getElementById('analysisContainer');

        let score, lives, difficultyLevel, gameOver, gameRunning, lastMeteorSpawn, lastEnemySpawn; let lastShot = 0; const shotCooldown = 250; 
        const ship = { x: 0, y: 0, width: 50, height: 50, speed: 7, color: '#00ffff', shieldHealth: 0, shieldRadius: 45 };
        const bullets = [], meteors = [], particles = [], powerups = [], enemies = [], enemyBullets = [], stars = [];
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, ' ': false, z: false };
        let gameStartTime = 0, elapsedTimeStr = '00:00', currentShipName = '';
        let boss = null; let isBossActive = false; let nextBossScore = 1000; let firstBossDefeated = false; let bossesDefeated = 0;
        let isLaserActive = false; let laserCharge = 100; let lastLaserTime = 0; const laserCooldown = 10000; const laserDuration = 1500; let laserActiveUntil = 0;
        let commsChatter = { text: '', alpha: 0, life: 0, maxLife: 240, color: '#00ffff' }; let lastChatterRequest = 0; const chatterInterval = 15000; 
        
        let isMuted = false;
        const muteButton = { x: 0, y: 55, width: 30, height: 30 };
        let kick, hihat, bassSynth, melodySeq;
        let isAudioReady = false;

        let isRapidFireActive = false, rapidFireUntil = 0;
        let isDoubleShotActive = false, doubleShotUntil = 0;

        function resizeCanvas() { 
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            muteButton.x = canvas.width - 50; 
        }

        function initializeGame() {
            resizeCanvas(); score = 0; lives = 5; difficultyLevel = 1; gameOver = false; gameRunning = true; ship.x = canvas.width / 2 - 25; ship.y = canvas.height - 80; ship.shieldHealth = 0;
            [bullets, meteors, particles, powerups, enemies, enemyBullets].forEach(arr => arr.length = 0);
            stars.length = 0; for (let i = 0; i < 150; i++) { stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 + 0.5, speed: Math.random() * 1.5 + 0.5 }); }
            lastMeteorSpawn = 0; lastEnemySpawn = 0; boss = null; isBossActive = false; nextBossScore = 1000; firstBossDefeated = false; bossesDefeated = 0;
            laserCharge = 100; lastLaserTime = -laserCooldown; isLaserActive = false;
            isRapidFireActive = false; rapidFireUntil = 0; isDoubleShotActive = false; doubleShotUntil = 0;
            commsChatter = { text: '', alpha: 0, life: 0, maxLife: 240, color: '#00ffff' }; lastChatterRequest = Date.now(); gameStartTime = Date.now();
            currentShipName = shipNameInput.value || 'Defensor Anónimo';
            gameOverScreen.classList.add('hidden'); gameOverScreen.classList.remove('flex'); analysisContainer.innerHTML = 'Aguardando análise...'; analysisContainer.classList.add('italic', 'text-gray-400');
            
            if (isAudioReady && typeof Tone !== 'undefined' && Tone.Transport.state !== 'started') {
                Tone.Transport.start();
            }

            gameLoop();
        }

        async function callGemini(prompt, targetElement, buttonToDisable) { 
            let originalButtonContent = ''; if(buttonToDisable) { originalButtonContent = buttonToDisable.innerHTML; buttonToDisable.innerHTML = '<div class="spinner"></div>'; buttonToDisable.disabled = true; } 
            if(targetElement) { targetElement.innerHTML = '<span class="animate-pulse">A gerar...</span>'; targetElement.classList.remove('italic', 'text-gray-400'); } 
            const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`; 
            try { 
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) }); 
                if (!response.ok) throw new Error(`API Error: ${response.statusText}`); 
                const result = await response.json(); const text = result.candidates?.[0]?.content?.parts?.[0]?.text; 
                if (text) { if(targetElement) targetElement.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); return text; } 
                else { throw new Error("Resposta da API inválida."); } 
            } catch (error) { console.error("Erro ao chamar a API Gemini:", error); const errorMessage = "Ocorreu um erro de comunicação. Tente novamente."; if(targetElement) targetElement.innerHTML = errorMessage; return errorMessage; 
            } finally { if(buttonToDisable) { buttonToDisable.innerHTML = originalButtonContent; buttonToDisable.disabled = false; } } 
        }
        async function generateShipName() { generateNameButton.disabled = true; generateNameButton.innerHTML = '<div class="spinner w-4 h-4"></div>'; shipNameInput.value = "A gerar..."; const prompt = "Gere um nome criativo, sonoro e épico para uma nave espacial solitária. O nome deve ser curto, no máximo 2 ou 3 palavras. Responda apenas com o nome e mais nada. Exemplos: Vingança Estelar, Lâmina de Orion, Sussurro do Vazio."; const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`; try { const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) }); const result = await response.json(); shipNameInput.value = result.candidates?.[0]?.content?.parts?.[0]?.text.trim() || "Defensor Padrão"; shipNameInput.dispatchEvent(new Event('input')); } catch (error) { console.error("Erro ao gerar nome da nave:", error); shipNameInput.value = "Defensor Padrão"; } finally { generateNameButton.disabled = false; generateNameButton.textContent = '✨'; } }
        async function generateChatter() { 
            let prompt = '';
            if (isBossActive) { prompt = `Você é a IA de uma nave-mãe inimiga arrogante, lutando contra uma pequena nave humana chamada '${currentShipName}'. Gere uma única frase de rádio curta, intimidatória ou provocadora para o piloto. Seja conciso. Não use aspas. Exemplos: "Seus esforços são fúteis, pequena nave.", "Essa sua arma de brincar mal arranha a minha pintura.", "Os meus escudos são eternos. A sua esperança não."`; commsChatter.color = '#FF00FF'; } 
            else { let context = "geral"; if (score > 1500) context = "de vitória"; else if (lives <= 2) context = "de perigo"; prompt = `Gere uma única frase curta de comunicação de rádio para um jogo de batalha espacial. O tom deve ser ${context}. A mensagem deve ser concisa e imersiva. Não use aspas. Exemplos: "Os escudos estão a falhar!", "Aguenta, reforços a caminho!", "Excelente tiro, piloto!", "Transmissão não identificada na frequência 3.7."`; commsChatter.color = '#00ffff'; }
            const chatter = await callGemini(prompt, null, null); 
            if (chatter && !chatter.startsWith("Ocorreu um erro")) { commsChatter.text = `> ${chatter.trim()}`; commsChatter.life = commsChatter.maxLife; commsChatter.alpha = 0; } 
        }
        
        function setupAudio() { if (bassSynth) return; bassSynth = new Tone.MonoSynth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.2, release: 0.5 }, filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.5, baseFrequency: 200, octaves: 4 } }).toDestination(); kick = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' } }).toDestination(); hihat = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination(); const sequence = [ 'C2', 'G2', 'Bb2', 'G2', 'C2', 'G2', 'Eb3', 'G2', 'F2', 'C3', 'D#3', 'C3', 'F2', 'C3', 'D#3', 'C3' ]; melodySeq = new Tone.Sequence((time, note) => { bassSynth.triggerAttackRelease(note, '16n', time); }, sequence, '8n').start(0); const drumLoop = new Tone.Loop(time => { kick.triggerAttackRelease('C1', '8n', time); hihat.triggerAttackRelease('16n', time + Tone.Time('8n').toSeconds()); hihat.triggerAttackRelease('16n', time + Tone.Time('4n').toSeconds()); hihat.triggerAttackRelease('16n', time + Tone.Time('4n').toSeconds() + Tone.Time('8n').toSeconds()); }, '4n').start(0); Tone.Transport.bpm.value = 130; }
        function toggleMute() { isMuted = !isMuted; if (typeof Tone !== 'undefined') { Tone.Destination.mute = isMuted; } }

        window.addEventListener('resize', resizeCanvas);
        startButton.addEventListener('click', async () => { 
            if (!isAudioReady && typeof Tone !== 'undefined') {
                try {
                    await Tone.start();
                    console.log("Audio context started");
                    setupAudio();
                    isAudioReady = true;
                } catch (e) {
                    console.error("Não foi possível iniciar o contexto de áudio, o jogo continuará sem som:", e);
                }
            }
            startScreen.style.display = 'none'; 
            canvas.classList.remove('hidden'); 
            initializeGame(); 
        });
        restartButton.addEventListener('click', () => { startScreen.style.display = 'flex'; canvas.classList.add('hidden'); gameOverScreen.classList.add('hidden'); gameOverScreen.classList.remove('flex'); if (typeof Tone !== 'undefined' && Tone.Transport.state === 'started') Tone.Transport.stop(); });
        generateNameButton.addEventListener('click', generateShipName);
        shipNameInput.addEventListener('input', () => { startButton.disabled = shipNameInput.value.trim() === ''; });
        analyzePerformanceButton.addEventListener('click', async () => { const shipName = shipNameInput.value || "Defensor Padrão"; const prompt = `Você é um oficial de debriefing de missão espirituoso e ligeiramente sarcástico. Um piloto acabou de terminar uma missão contra um enxame de meteoros e naves inimigas na sua nave, a **${shipName}**. A sua pontuação final foi de **${score}** e alcançou o nível de dificuldade **${Math.floor(difficultyLevel)}**. Escreva uma análise curta e engraçada, de um parágrafo, do seu desempenho. Se a pontuação for baixa (abaixo de 500), seja mais sarcástico. Se a pontuação for alta (acima de 2000), mostre-se mais impressionado, mas ainda com um toque de humor.`; await callGemini(prompt, analysisContainer, analyzePerformanceButton); });
        generateLogButton.addEventListener('click', async () => { const shipName = shipNameInput.value || "Defensor Padrão"; const prompt = `Você é o capitão da nave espacial **${shipName}**. Escreva uma entrada final e dramática no diário de bordo, com 2-3 parágrafos, após uma batalha feroz contra meteoros e caças inimigos. A sua pontuação foi **${score}**. Reflita sobre a intensidade da batalha, as perdas (se a pontuação for baixa) ou a vitória esmagadora (se a pontuação for alta). Termine com um tom sombrio ou esperançoso, dependendo do resultado.`; await callGemini(prompt, analysisContainer, generateLogButton); });
        window.addEventListener('keydown', (e) => { if (keys.hasOwnProperty(e.key)) { e.preventDefault(); keys[e.key] = true; } if (e.key.toLowerCase() === 'r' && gameOver) restartButton.click(); });
        window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
        canvas.addEventListener('click', (event) => { const rect = canvas.getBoundingClientRect(); const x = event.clientX - rect.left; const y = event.clientY - rect.top; if (x >= muteButton.x && x <= muteButton.x + muteButton.width && y >= muteButton.y && y <= muteButton.y + muteButton.height) { toggleMute(); } });
        historyButton.addEventListener('click', () => { historyScreen.classList.remove('hidden'); historyScreen.classList.add('flex'); fetchHistory(); });
        closeHistoryButton.addEventListener('click', () => { historyScreen.classList.add('hidden'); historyScreen.classList.remove('flex'); });

        function setupMobileControls() {
            const fireButton = document.getElementById('fireButton'); const laserButton = document.getElementById('laserButton');
            fireButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys[' '] = true; }, { passive: false }); fireButton.addEventListener('touchend', (e) => { e.preventDefault(); keys[' '] = false; }, { passive: false });
            laserButton.addEventListener('touchstart', (e) => { e.preventDefault(); keys['z'] = true; }, { passive: false }); laserButton.addEventListener('touchend', (e) => { e.preventDefault(); keys['z'] = false; }, { passive: false });
            const joystickArea = document.getElementById('joystick-area'); const joystickKnob = document.getElementById('joystick-knob');
            let joystickTouchId = null; const joystickRadius = joystickArea.offsetWidth / 2 - joystickKnob.offsetWidth / 2;
            const resetJoystick = () => { joystickKnob.style.transition = 'transform 0.1s ease-out'; joystickKnob.style.transform = 'translate(-50%, -50%)'; keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false; joystickTouchId = null; };
            joystickArea.addEventListener('touchstart', (e) => { e.preventDefault(); if (joystickTouchId === null) { const touch = e.changedTouches[0]; joystickTouchId = touch.identifier; joystickKnob.style.transition = 'none'; } }, { passive: false });
            window.addEventListener('touchmove', (e) => { if (joystickTouchId === null) return; e.preventDefault(); let touch = null; for(let i=0; i < e.touches.length; i++) { if (e.touches[i].identifier === joystickTouchId) { touch = e.touches[i]; break; } }
                if (touch) { const rect = joystickArea.getBoundingClientRect(); const joystickCenterX = rect.left + rect.width / 2; const joystickCenterY = rect.top + rect.height / 2; let dx = touch.clientX - joystickCenterX; let dy = touch.clientY - joystickCenterY; const distance = Math.hypot(dx, dy); if (distance > joystickRadius) { dx = (dx / distance) * joystickRadius; dy = (dy / distance) * joystickRadius; }
                    joystickKnob.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                    const deadzone = joystickRadius * 0.3; 
                    keys.ArrowRight = dx > deadzone; keys.ArrowLeft = dx < -deadzone; keys.ArrowDown = dy > deadzone; keys.ArrowUp = dy < -deadzone;
                }
            }, { passive: false });
            const touchEndHandler = (e) => { for (let i=0; i < e.changedTouches.length; i++) { if (e.changedTouches[i].identifier === joystickTouchId) { resetJoystick(); break; } } };
            window.addEventListener('touchend', touchEndHandler); window.addEventListener('touchcancel', touchEndHandler);
        }
        
        function hexToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }
        function createExplosion(x, y, color, count = 20) { for (let i = 0; i < count; i++) { particles.push({ x, y, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, size: Math.random() * 3 + 1, life: Math.random() * 40 + 20, color: color }); } }
        function spawnMeteor() { let size, health; const sizeType = Math.random(); if (sizeType < 0.5) { size = 30; health = 1; } else if (sizeType < 0.85) { size = 45; health = 2; } else { size = 65; health = 4; } const meteor = { x: Math.random() * (canvas.width - size), y: -size, size, speed: (Math.random() * 1.5 + 1) * difficultyLevel, health, points: 30, angle: 0, rotationSpeed: (Math.random() - 0.5) * 0.02, vertices: [], craters: [] }; const numVertices = 12; for (let i = 0; i < numVertices; i++) { const angle = (i / numVertices) * Math.PI * 2; const radius = meteor.size / 2 * (Math.random() * 0.3 + 0.85); meteor.vertices.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius }); } for (let i=0; i < 5; i++) { const angle = Math.random() * Math.PI * 2; const radius = Math.random() * (meteor.size / 3); meteor.craters.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius, radius: Math.random() * 4 + 2 }); } meteors.push(meteor); }
        function spawnEnemy(typeOverride = null) { let enemyType = typeOverride; if (!typeOverride) { const rand = Math.random(); if (bossesDefeated >= 2 && rand < 0.25) { enemyType = 'green'; } else if (firstBossDefeated && rand < 0.60) { enemyType = 'yellow'; } else { enemyType = 'red'; } } if (enemyType === 'red') { enemies.push({ type: 'red', x: Math.random() * (canvas.width - 40), y: -40, width: 40, height: 30, speedX: (Math.random() - 0.5) * 4, speedY: 1 * difficultyLevel, health: 3, lastShot: Date.now(), shotCooldown: 2000 / difficultyLevel, points: 60 }); } else if (enemyType === 'green') { enemies.push({ type: 'green', x: Math.random() * (canvas.width - 40), y: -40, width: 40, height: 40, speedX: 2.5 * difficultyLevel, speedY: 1 * difficultyLevel, health: 5, lastShot: Date.now(), shotCooldown: 2200 / difficultyLevel, points: 90, phase: 'descending', targetY: Math.random() * 100 + 50 }); } else { enemies.push({ type: 'yellow', x: Math.random() * (canvas.width - 40), y: -40, width: 35, height: 40, speedX: 0, speedY: 1.5 * difficultyLevel, health: 4, lastShot: Date.now(), shotCooldown: 1500 / difficultyLevel, points: 75, phase: 'down', moveRange: { top: Math.random() * 100 + 80, bottom: Math.random() * 100 + 250 } }); } }
        function spawnBoss() { isBossActive = true; [enemies, meteors, enemyBullets].forEach(arr => arr.length = 0); warningText.style.display = 'block'; setTimeout(() => { warningText.style.display = 'none'; boss = { x: canvas.width / 2 - 100, y: -200, width: 200, height: 120, speedX: 2 * difficultyLevel, health: 150 * difficultyLevel, maxHealth: 150 * difficultyLevel, phase: 'entering', phaseTime: Date.now(), lastShot: Date.now(), shotCooldown: 1000, shotPattern: 0, lastMinionSpawn: Date.now() }; }, 3000); }

        function drawShip() { const { x, y, width, height } = ship; if (Object.values(keys).some(k => k)) { ctx.fillStyle = `rgba(255, 180, 50, ${Math.random() * 0.5 + 0.5})`; ctx.beginPath(); ctx.moveTo(x + width/2 - 6, y + height); ctx.lineTo(x + width/2 + 6, y + height); ctx.lineTo(x + width/2, y + height + Math.random() * 20 + 15); ctx.closePath(); ctx.fill(); } ctx.fillStyle = '#B0C4DE'; ctx.beginPath(); ctx.moveTo(x + width/2, y); ctx.lineTo(x, y + height * 0.85); ctx.lineTo(x + width/2, y + height); ctx.lineTo(x + width, y + height * 0.85); ctx.closePath(); ctx.fill(); ctx.fillStyle = ship.color; ctx.beginPath(); ctx.moveTo(x + width/2, y + 5); ctx.lineTo(x + width/2 - 5, y + 20); ctx.lineTo(x + width/2 + 5, y + 20); ctx.closePath(); ctx.fill(); if (ship.shieldHealth > 0) { ctx.lineWidth = 2.5; for (let i = 0; i < ship.shieldHealth; i++) { const radius = ship.shieldRadius - (i * 7); const alpha = 0.4 + (i * 0.2); ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`; ctx.beginPath(); ctx.arc(x + width / 2, y + height / 2, radius, 0, Math.PI * 2); ctx.stroke(); } } }
        function drawBoss() { if (!boss) return; ctx.fillStyle = '#4B0082'; ctx.fillRect(boss.x, boss.y, boss.width, boss.height); ctx.fillStyle = '#FF00FF'; ctx.fillRect(boss.x + boss.width/2 - 20, boss.y + 20, 40, 30); ctx.fillStyle = '#8A2BE2'; ctx.beginPath(); ctx.moveTo(boss.x, boss.y + 20); ctx.lineTo(boss.x - 40, boss.y + 80); ctx.lineTo(boss.x, boss.y + 80); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(boss.x + boss.width, boss.y + 20); ctx.lineTo(boss.x + boss.width + 40, boss.y + 80); ctx.lineTo(boss.x + boss.width, boss.y + 80); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#8B0000'; ctx.fillRect(boss.x, boss.y - 20, boss.width, 10); const healthPercent = boss.health / boss.maxHealth; ctx.fillStyle = '#00FF00'; ctx.fillRect(boss.x, boss.y - 20, boss.width * healthPercent, 10); }
        function drawLaser() { if (!isLaserActive) return; const laserWidth = 20; const grad = ctx.createLinearGradient(ship.x, 0, ship.x + laserWidth, 0); grad.addColorStop(0, 'rgba(255, 0, 0, 0.1)'); grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)'); grad.addColorStop(1, 'rgba(255, 0, 0, 0.1)'); ctx.fillStyle = grad; ctx.shadowColor = 'red'; ctx.shadowBlur = 30; ctx.fillRect(ship.x + ship.width / 2 - laserWidth / 2, -10, laserWidth, ship.y + 10); ctx.shadowBlur = 0; }
        function drawEnemies() { enemies.forEach(enemy => { if (enemy.type === 'red') { ctx.fillStyle = '#ff4d4d'; ctx.beginPath(); ctx.moveTo(enemy.x, enemy.y); ctx.lineTo(enemy.x + enemy.width, enemy.y); ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height); ctx.closePath(); ctx.fill(); } else if (enemy.type === 'green') { ctx.fillStyle = '#22c55e'; ctx.beginPath(); ctx.moveTo(enemy.x + enemy.width/2, enemy.y); ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height/2); ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height); ctx.lineTo(enemy.x, enemy.y + enemy.height/2); ctx.closePath(); ctx.fill(); } else { ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.moveTo(enemy.x + enemy.width/2, enemy.y); ctx.lineTo(enemy.x, enemy.y + enemy.height); ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height); ctx.closePath(); ctx.fill(); } }); }
        function drawEnemyBullets() { enemyBullets.forEach(b => { ctx.fillStyle = '#ff8c00'; ctx.shadowColor = '#ff8c00'; ctx.shadowBlur = 10; ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; }); }
        function drawStars() { ctx.fillStyle = '#FFFFFF'; stars.forEach(star => { ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill(); }); }
        function drawBullets() { bullets.forEach(bullet => { ctx.shadowBlur = 15; ctx.fillStyle = '#FFF'; ctx.shadowColor = '#00ffff'; ctx.beginPath(); ctx.arc(bullet.x, bullet.y, 6, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; }); }
        function drawMeteors() { meteors.forEach(meteor => { meteor.angle += meteor.rotationSpeed; ctx.save(); ctx.translate(meteor.x, meteor.y); ctx.rotate(meteor.angle); const grad = ctx.createRadialGradient(0, 0, meteor.size / 4, 0, 0, meteor.size / 1.5); grad.addColorStop(0, '#C0C0C0'); grad.addColorStop(1, '#696969'); ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(meteor.vertices[0].x, meteor.vertices[0].y); for (let i = 1; i < meteor.vertices.length; i++) { ctx.lineTo(meteor.vertices[i].x, meteor.vertices[i].y); } ctx.closePath(); ctx.fill(); ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; meteor.craters.forEach(crater => { ctx.beginPath(); ctx.arc(crater.x, crater.y, crater.radius, 0, Math.PI * 2); ctx.fill(); }); ctx.strokeStyle = '#404040'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); }); }
        function drawParticles() { particles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); }); }
        function drawPowerups() { powerups.forEach(p => { ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 2; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 15; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#FFFFFF'; ctx.font = 'bold 14px Orbitron'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('S', p.x, p.y); ctx.shadowBlur = 0; ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic'; }); }
        
        function drawHUD() { const isSmallScreen = canvas.width < 768; const topRowY = isSmallScreen ? 30 : 40; const secondRowY = isSmallScreen ? 55 : 70; const topFontSize = isSmallScreen ? '16px' : '20px'; const secondFontSize = isSmallScreen ? '12px' : '14px'; ctx.fillStyle = '#FFFFFF'; ctx.font = `${topFontSize} Orbitron`; ctx.textAlign = 'left'; ctx.fillText(`NAVE: ${currentShipName.substring(0, 15)}`, 20, topRowY); ctx.textAlign = 'right'; ctx.fillText(`PONTOS: ${score}`, canvas.width - 20, topRowY); ctx.font = `${secondFontSize} Orbitron`; ctx.textAlign = 'left'; let currentX = 20; ctx.fillText(`VIDAS:`, currentX, secondRowY); currentX += (isSmallScreen ? 45 : 60); for (let i = 0; i < lives; i++) { ctx.save(); ctx.translate(currentX + (i * 15), secondRowY - 8); ctx.scale(0.25, 0.25); ctx.fillStyle = '#B0C4DE'; ctx.beginPath(); ctx.moveTo(ship.width/2, 0); ctx.lineTo(0, ship.height * 0.85); ctx.lineTo(ship.width/2, ship.height); ctx.lineTo(ship.width, ship.height * 0.85); ctx.closePath(); ctx.fill(); ctx.restore(); } currentX += (lives * 15) + 15; ctx.fillText(`TEMPO: ${elapsedTimeStr}`, currentX, secondRowY); currentX += (isSmallScreen ? 90 : 130); const barWidth = isSmallScreen ? 70 : 110; const barHeight = isSmallScreen ? 10 : 12; ctx.fillText('LASER:', currentX, secondRowY); currentX += (isSmallScreen ? 45 : 65); const laserBarY = secondRowY - (isSmallScreen ? 8 : 10); ctx.strokeStyle = laserCharge >= 100 ? '#ff4500' : '#8B0000'; ctx.lineWidth = 1; ctx.strokeRect(currentX, laserBarY, barWidth, barHeight); const chargePercent = laserCharge / 100; const laserGradient = ctx.createLinearGradient(currentX, 0, currentX + barWidth, 0); laserGradient.addColorStop(0, '#8B0000'); laserGradient.addColorStop(1, '#ff4500'); ctx.fillStyle = laserGradient; ctx.fillRect(currentX, laserBarY, barWidth * chargePercent, barHeight); if (laserCharge >= 100) { ctx.fillStyle = '#FFFFFF'; ctx.font = `bold ${isSmallScreen ? '8px': '10px'} Orbitron`; ctx.textAlign = 'center'; ctx.fillText("PRONTO", currentX + barWidth/2, secondRowY - 1); } currentX += barWidth + 15; if (!isBossActive && canvas.width > 550) { const progressRequired = (bossesDefeated >= 2 ? 1500 : 1000); const scoreSinceLastBoss = score - (nextBossScore - progressRequired); const progressPercent = Math.max(0, scoreSinceLastBoss / progressRequired); ctx.font = `${secondFontSize} Orbitron`; ctx.textAlign = 'left'; ctx.fillText('CHEFE:', currentX, secondRowY); currentX += (isSmallScreen ? 45 : 65); const bossBarY = secondRowY - (isSmallScreen ? 8 : 10); ctx.strokeStyle = '#8A2BE2'; ctx.lineWidth = 1; ctx.strokeRect(currentX, bossBarY, barWidth, barHeight); const bossGradient = ctx.createLinearGradient(currentX, 0, currentX + barWidth, 0); bossGradient.addColorStop(0, '#4B0082'); bossGradient.addColorStop(1, '#FF00FF'); ctx.fillStyle = bossGradient; ctx.fillRect(currentX, bossBarY, barWidth * progressPercent, barHeight); }
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.strokeRect(muteButton.x, muteButton.y, muteButton.width, muteButton.height); ctx.beginPath(); ctx.moveTo(muteButton.x + 5, muteButton.y + 10); ctx.lineTo(muteButton.x + 10, muteButton.y + 10); ctx.lineTo(muteButton.x + 15, muteButton.y + 5); ctx.lineTo(muteButton.x + 15, muteButton.y + 25); ctx.lineTo(muteButton.x + 10, muteButton.y + 20); ctx.lineTo(muteButton.x + 5, muteButton.y + 20); ctx.closePath(); ctx.stroke(); if (isMuted) { ctx.beginPath(); ctx.moveTo(muteButton.x + 5, muteButton.y + 5); ctx.lineTo(muteButton.x + 25, muteButton.y + 25); ctx.stroke(); } drawChatter(); }
        function drawChatter() { if (commsChatter.alpha > 0) { ctx.textAlign = 'center'; ctx.font = `italic ${canvas.width < 768 ? '12px' : '16px'} Orbitron`; const rgb = hexToRgb(commsChatter.color); if (rgb) { ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${commsChatter.alpha})`; ctx.shadowColor = commsChatter.color; ctx.shadowBlur = 10; ctx.fillText(commsChatter.text, canvas.width / 2, canvas.height - 25); ctx.shadowBlur = 0; } } }
        
        function updateState() { if (gameOver) return; const elapsed = Math.floor((Date.now() - gameStartTime) / 1000); const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0'); const seconds = String(elapsed % 60).padStart(2, '0'); elapsedTimeStr = `${minutes}:${seconds}`; if (isLaserActive && Date.now() > laserActiveUntil) isLaserActive = false; laserCharge = Math.min(100, ((Date.now() - lastLaserTime) / laserCooldown) * 100); if (keys.ArrowUp && ship.y > 0) ship.y -= ship.speed; if (keys.ArrowDown && ship.y < canvas.height - ship.height) ship.y += ship.speed; if (keys.ArrowLeft && ship.x > 0) ship.x -= ship.speed; if (keys.ArrowRight && ship.x < canvas.width - ship.width) ship.x += ship.speed; if (keys[' '] && Date.now() - lastShot > shotCooldown) { bullets.push({ x: ship.x + ship.width / 2, y: ship.y }); lastShot = Date.now(); } if (keys.z && laserCharge >= 100) { isLaserActive = true; laserActiveUntil = Date.now() + laserDuration; lastLaserTime = Date.now(); }
            if (!isBossActive && score >= nextBossScore) { spawnBoss(); } if (isBossActive) { updateBoss(); } else { if (Date.now() - lastMeteorSpawn > 2000 / difficultyLevel) { spawnMeteor(); lastMeteorSpawn = Date.now(); } if (Date.now() - lastEnemySpawn > 5000 / difficultyLevel) { spawnEnemy(); lastEnemySpawn = Date.now(); } }
            bullets.forEach((b, i) => { b.y -= 10; if (b.y < 0) bullets.splice(i, 1); }); meteors.forEach((m, i) => { m.y += m.speed; if (m.y > canvas.height + m.size) meteors.splice(i, 1); }); enemies.forEach((e, i) => { if (e.type === 'green') { if (e.phase === 'descending') { e.y += e.speedY; if (e.y >= e.targetY) { e.phase = 'horizontal'; } } else { e.x += e.speedX; if (e.x <= 0 || e.x >= canvas.width - e.width) { e.speedX *= -1; } } } else if (e.type === 'yellow') { if (e.phase === 'down') { e.y += e.speedY; if (e.y >= e.moveRange.bottom) e.phase = 'up'; } else { e.y -= e.speedY; if (e.y <= e.moveRange.top) e.phase = 'down'; } } else { e.x += e.speedX; e.y += e.speedY; if (e.x <= 0 || e.x >= canvas.width - e.width) e.speedX *= -1; } if (e.y > canvas.height + e.height) enemies.splice(i, 1); if (Date.now() - e.lastShot > e.shotCooldown) { enemyBullets.push({x: e.x + e.width/2, y: e.y + e.height}); if (e.type === 'yellow') { enemyBullets.push({x: e.x + e.width/2 - 10, y: e.y + e.height}); enemyBullets.push({x: e.x + e.width/2 + 10, y: e.y + e.height}); } e.lastShot = Date.now(); } }); enemyBullets.forEach((b, i) => { b.y += 5; if (b.y > canvas.height) enemyBullets.splice(i, 1); }); powerups.forEach((p, i) => { p.y += 2; if(p.y > canvas.height + p.size) powerups.splice(i, 1); }); particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); }); stars.forEach(star => { star.y += star.speed; if (star.y > canvas.height) { star.y = 0; star.x = Math.random() * canvas.width; } }); updateChatter(); checkCollisions(); }
        function updateBoss() { if (!boss) return; if (boss.phase === 'entering') { boss.y += 3; if (boss.y >= 50) { boss.phase = 'attacking'; } } else if (boss.phase === 'attacking') { boss.x += boss.speedX; if (boss.x <= 0 || boss.x + boss.width >= canvas.width) { boss.speedX *= -1; } if (Date.now() - boss.lastShot > boss.shotCooldown) { for (let i = -2; i <= 2; i++) { enemyBullets.push({ x: boss.x + boss.width/2 + (i * 40), y: boss.y + boss.height }); } boss.lastShot = Date.now(); } const minionSpawnRate = 4500 / difficultyLevel; if (Date.now() - boss.lastMinionSpawn > minionSpawnRate) { if (bossesDefeated === 1 || bossesDefeated === 2) { spawnEnemy('red'); } else if (bossesDefeated >= 3) { spawnEnemy(Math.random() < 0.5 ? 'red' : 'yellow'); } boss.lastMinionSpawn = Date.now(); } } }
        function updateChatter() { if (gameRunning && Date.now() - lastChatterRequest > chatterInterval) { generateChatter(); lastChatterRequest = Date.now(); } if (commsChatter.life > 0) { commsChatter.life--; const lifePercentage = commsChatter.life / commsChatter.maxLife; if (lifePercentage > 0.8) { commsChatter.alpha = (1 - lifePercentage) / 0.2; } else if (lifePercentage < 0.2) { commsChatter.alpha = lifePercentage / 0.2; } else { commsChatter.alpha = 1; } } else { commsChatter.alpha = 0; } }
        
        function checkCollisions() {
            const bulletRadius = 6;
            if (isLaserActive) { const laserX = ship.x + ship.width / 2; const laserWidth = 20; meteors.slice().reverse().forEach((meteor, i) => { if (Math.abs(laserX - meteor.x) < meteor.size / 2 + laserWidth / 2) { score += meteor.points; createExplosion(meteor.x, meteor.y, '#ff4500', meteor.size); meteors.splice(meteors.length - 1 - i, 1); } }); enemies.slice().reverse().forEach((enemy, i) => { if (laserX > enemy.x && laserX < enemy.x + enemy.width) { score += enemy.points; createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#ff4500', 40); enemies.splice(enemies.length - 1 - i, 1); } }); if (boss && laserX > boss.x && laserX < boss.x + boss.width) { boss.health -= 2; } }
            bullets.forEach((bullet, i) => { let bulletRemoved = false; meteors.forEach((meteor, j) => { if (!bulletRemoved && Math.hypot(bullet.x - meteor.x, bullet.y - meteor.y) < meteor.size / 2 + bulletRadius) { bullets.splice(i, 1); bulletRemoved = true; meteor.health--; createExplosion(bullet.x, bullet.y, '#FFA500', 5); if (meteor.health <= 0) { score += meteor.points; createExplosion(meteor.x, meteor.y, '#696969', meteor.size / 2); if(meteor.size >= 60 && Math.random() < 0.25) { powerups.push({ x: meteor.x, y: meteor.y, size: 20, type: 'shield' }); } meteors.splice(j, 1); } } }); enemies.forEach((enemy, j) => { if (!bulletRemoved && bullet.x > enemy.x && bullet.x < enemy.x + enemy.width && bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) { bullets.splice(i, 1); bulletRemoved = true; enemy.health--; if(enemy.health <= 0) { score += enemy.points; createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff4d4d', 30); enemies.splice(j, 1); } } }); if (boss && !bulletRemoved && bullet.x > boss.x && bullet.x < boss.x + boss.width && bullet.y > boss.y && bullet.y < boss.y + boss.height) { bullets.splice(i, 1); bulletRemoved = true; boss.health--; createExplosion(bullet.x, bullet.y, '#FFD700', 5); if (boss.health <= 0) { createExplosion(boss.x + boss.width/2, boss.y + boss.height/2, '#FF00FF', 200); difficultyLevel += 0.5; bossesDefeated++; const progressRequired = (bossesDefeated >= 2 ? 1500 : 1000); nextBossScore = score + progressRequired; boss = null; isBossActive = false; firstBossDefeated = true; } } });
            enemyBullets.forEach((b, i) => { if (Math.hypot(b.x - (ship.x+ship.width/2), b.y - (ship.y+ship.height/2)) < ship.width/2) { enemyBullets.splice(i,1); if(ship.shieldHealth > 0){ship.shieldHealth--; createExplosion(ship.x+ship.width/2, ship.y+ship.height/2, '#00ffff', 40);} else {lives--; createExplosion(ship.x+ship.width/2, ship.y+ship.height/2, '#FF4500', 30); if(lives <= 0) endGame();} } });
            const checkPlayerCollision = (obj, isMeteor) => { const objWidth = isMeteor ? obj.size : (obj.width || 0); const objX = isMeteor ? obj.x : (obj.x + objWidth / 2); const dist = Math.hypot((ship.x + ship.width/2) - objX, (ship.y + ship.height/2) - (obj.y + objWidth/2)); if (dist < objWidth/2 + ship.width/2) { if (ship.shieldHealth > 0) { ship.shieldHealth--; createExplosion(objX, obj.y + objWidth/2, '#00ffff', 40); } else { lives--; createExplosion(ship.x+ship.width/2, ship.y+ship.height/2, '#FF4500', 30); if(lives <= 0) endGame(); } return true; } return false; };
            meteors.forEach((m, i) => { if(checkPlayerCollision(m, true)) meteors.splice(i, 1); }); enemies.forEach((e, i) => { if(checkPlayerCollision(e, false)) { enemies.splice(i,1); createExplosion(e.x+e.width/2, e.y+e.height/2, '#ff4d4d', 30); } }); if (boss && checkPlayerCollision(boss, false)) { /* Player takes damage from boss collision */ }
            powerups.forEach((p, i) => { if(Math.hypot((ship.x + ship.width/2) - p.x, (ship.y + ship.height/2) - p.y) < p.size + ship.width/2) { if(p.type === 'shield') ship.shieldHealth = 3; powerups.splice(i, 1); } });
        }

        function endGame() { 
            gameOver = true; gameRunning = false; finalScoreElement.textContent = score; 
            gameOverScreen.classList.remove('hidden'); gameOverScreen.classList.add('flex');
            if (typeof Tone !== 'undefined' && Tone.Transport.state === 'started') Tone.Transport.stop();
            saveHistory();
        }

        function saveHistory() {
            try {
                const history = JSON.parse(localStorage.getItem('spaceDefenderHistory')) || [];
                history.push({ shipName: currentShipName, score: score });
                history.sort((a, b) => b.score - a.score);
                const trimmedHistory = history.slice(0, 50);
                localStorage.setItem('spaceDefenderHistory', JSON.stringify(trimmedHistory));
                console.log("Partida guardada localmente!");
            } catch (error) {
                console.error("Erro ao guardar a partida no localStorage:", error);
            }
        }

        function fetchHistory() {
            historyTableBody.innerHTML = '';
            try {
                const history = JSON.parse(localStorage.getItem('spaceDefenderHistory')) || [];
                if (history.length === 0) {
                    historyTableBody.innerHTML = `<tr><td colspan="2">Ainda não há partidas registadas.</td></tr>`;
                    return;
                }
                history.forEach(data => {
                    const row = `<tr><td>${data.shipName}</td><td>${data.score}</td></tr>`;
                    historyTableBody.innerHTML += row;
                });
            } catch (error) {
                console.error("Erro ao carregar o histórico do localStorage:", error);
                historyTableBody.innerHTML = `<tr><td colspan="2">Ocorreu um erro ao carregar o histórico.</td></tr>`;
            }
        }

        function gameLoop() { if (!gameRunning) return; updateState(); ctx.clearRect(0, 0, canvas.width, canvas.height); drawStars(); drawPowerups(); drawMeteors(); drawEnemies(); if(isBossActive) drawBoss(); drawShip(); drawLaser(); drawBullets(); drawEnemyBullets(); drawParticles(); drawHUD(); requestAnimationFrame(gameLoop); }
    
        setupMobileControls();
        resizeCanvas();
    </script>
</body>
</html>

